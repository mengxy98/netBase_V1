<!DOCTYPE html>
<html>
    <head>
        <title>sat</title>
    </head>
    <body>
        <canvas id="cvs"></canvas>

        <script>
            /**
            * Helper function to determine whether there is an intersection between the two polygons described
            * by the lists of vertices. Uses the Separating Axis Theorem
            *
            * @param a an array of connected points [{x:, y:}, {x:, y:},...] that form a closed polygon
            * @param b an array of connected points [{x:, y:}, {x:, y:},...] that form a closed polygon
            * @return true if there is any intersection between the 2 polygons, false otherwise
            */
            function doPolygonsIntersect (a, b) {
                var polygons = [a, b];
                var minA, maxA, projected, i, i1, j, minB, maxB;

                function isUndefined(obj){
                    return obj === void 0;
                }

                for (i = 0; i < polygons.length; i++) {

                    // for each polygon, look at each edge of the polygon, and determine if it separates
                    // the two shapes
                    var polygon = polygons[i];
                    for (i1 = 0; i1 < polygon.length; i1++) {

                        // grab 2 vertices to create an edge
                        var i2 = (i1 + 1) % polygon.length;
                        var p1 = polygon[i1];
                        var p2 = polygon[i2];

                        // find the line perpendicular to this edge
                        var normal = { x: p2.y - p1.y, y: p1.x - p2.x };

                        minA = maxA = undefined;
                        // for each vertex in the first shape, project it onto the line perpendicular to the edge
                        // and keep track of the min and max of these values
                        for (j = 0; j < a.length; j++) {
                            projected = normal.x * a[j].x + normal.y * a[j].y;
                            if (isUndefined(minA) || projected < minA) {
                                minA = projected;
                            }
                            if (isUndefined(maxA) || projected > maxA) {
                                maxA = projected;
                            }
                        }

                        // for each vertex in the second shape, project it onto the line perpendicular to the edge
                        // and keep track of the min and max of these values
                        minB = maxB = undefined;
                        for (j = 0; j < b.length; j++) {
                            projected = normal.x * b[j].x + normal.y * b[j].y;
                            if (isUndefined(minB) || projected < minB) {
                                minB = projected;
                            }
                            if (isUndefined(maxB) || projected > maxB) {
                                maxB = projected;
                            }
                        }

                        // if there is no overlap between the projects, the edge we are looking at separates the two
                        // polygons, and we know there is no overlap
                        if (maxA < minB || maxB < minA) {
                            return false;
                        }
                    }
                }
                return true;
            };
            var canvas = document.getElementById('cvs');
            var ctx = canvas.getContext('2d');

            ctx.fillRect(0,0,100,100);

            function drawRect(rect){

                if (canvas.getContext) {

                  // use getContext to use the canvas for drawing

                  ctx.beginPath();
                  for(var i=0,len=rect.length;i<=len;i++){
                      // Draw shapes
                      if(i == 0){
                          ctx.moveTo(rect[i].x, rect[i].y);
                      }else if(i == len){
                          ctx.lineTo(rect[0].x, rect[0].y);
                      }else{
                          ctx.lineTo(rect[i].x, rect[i].y);
                          ctx.moveTo(rect[i].x, rect[i].y);
                      }
                  }
                  ctx.stroke();
                } else {
                  alert('You need Safari or Firefox 1.5+ to see this demo.');
                }

            }

            function fillRect(ctx,data){
                if(data.fillStyle){
                    ctx.fillStyle = data.fillStyle;
                }
                ctx.fillRect(data.x,data.y,data.width,data.height);
            }

            function rotate(points,rads) {

            	for (var i = 0; i < points.length; i++) {
            		var x = points[i].x;
            		var y = points[i].y;
            		points[i].x = Math.cos(rads) * x - Math.sin(rads) * y;
            		points[i].y = Math.sin(rads) * x + Math.cos(rads) * y;
            	}

                return points;
            }


            // var r1 = [{x:50,y:70},{x:90,y:70},{x:90,y:80},{x:50,y:80}];
            // drawRect(r1)
            // drawRect(rotate(r1,Math.PI/6))


            function hslToRgb(h, s, l){
                var r, g, b;

                if(s == 0){
                    r = g = b = l; // achromatic
                }else{
                    var hue2rgb = function hue2rgb(p, q, t){
                        if(t < 0) t += 1;
                        if(t > 1) t -= 1;
                        if(t < 1/6) return p + (q - p) * 6 * t;
                        if(t < 1/2) return q;
                        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    }

                    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    var p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }

                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            }

            function rgbToHsl(r, g, b){
                r /= 255, g /= 255, b /= 255;
                var max = Math.max(r, g, b), min = Math.min(r, g, b);
                var h, s, l = (max + min) / 2;

                if(max == min){
                    h = s = 0; // achromatic
                }else{
                    var d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch(max){
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }
                return {
                    val:[h, s, l],
                    str:'hsl('+[h, s*100+'%', l*100+'%'].join(',')+')'
                }
            }

            function getList(){
                var gap = 4;
                for(var i=0;i < 255;i+=gap){
                    for(var j=0;j< 255;j+=gap){
                        renderList.push({
                            x:i,
                            y:j,
                            width:gap,
                            height:gap,
                            fillStyle:'hsl('+(i)+',100%,50%)'
                        });

                        fillRect(ctx,{
                            x:i,
                            y:j,
                            width:gap,
                            height:gap,
                            fillStyle:'hsl('+(j*i)+',100%,50%)'
                        });
                    }
                }

            }

            var renderList = [];

            getList();

            //



            //var r2 = [{x:20,y:50},{x:30,y:40},{x:60,y:40},{x:20,y:60}];



            //drawRect(r1)

            //drawRect(r2)

            //console.log(doPolygonsIntersect(r1,r2));

        </script>
    </body>
</html>
